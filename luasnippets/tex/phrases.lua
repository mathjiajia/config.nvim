local snips, autosnips = {}, {}

local tex = require('utils.latex')

local pipe = function(fns)
	return function(...)
		for _, fn in ipairs(fns) do
			if not fn(...) then
				return false
			end
		end
		return true
	end
end

snips = {
	s(
		{ trig = 'ses', name = 'short exact sequence', dscr = 'text: short exact sequence.' },
		{ t('short exact sequence') },
		{ condition = tex.in_text, show_condition = tex.in_text }
	),

	s(
		{ trig = 'klt', name = 'Kawamata log terminal', dscr = 'text: Kawamata log terminal.' },
		{ t('Kawamata log terminal') },
		{ condition = tex.in_text, show_condition = tex.in_text }
	),
}

autosnips = {
	s({ trig = 'iee', name = 'id est', priority = 1100 }, { t('i.e., ') }, { condition = tex.in_text }),
	s({ trig = 'egg', name = 'exempli gratia', priority = 1100 }, { t('e.g., ') }, { condition = tex.in_text }),
	s({ trig = 'stt', name = 'such that', priority = 1100 }, { t('such that') }, { condition = tex.in_text }),
	s(
		{ trig = 'qf', name = 'Q-factorial', priority = 1100 },
		{ t('\\(\\mathbb{Q}\\)-factorial') },
		{ condition = tex.in_text }
	),
	s(
		{ trig = '([qr])c', name = 'Cartier', regTrig = true, priority = 1100 },
		{ f(function(_, snip)
			return '\\(\\mathbb{' .. string.upper(snip.captures[1]) .. '}\\)-Cartier'
		end, {}) },
		{ condition = tex.in_text }
	),
	s(
		{ trig = '([qr])d', name = 'divisor', regTrig = true, priority = 1100 },
		{ f(function(_, snip)
			return '\\(\\mathbb{' .. string.upper(snip.captures[1]) .. '}\\)-divisor'
		end, {}) },
		{ condition = tex.in_text }
	),
	s(
		{ trig = 'cd', name = 'Cartier divisor', priority = 1100 },
		{ t('Cartier divisor') },
		{ condition = tex.in_text }
	),
	s({ trig = 'wd', name = 'Weil divisor', priority = 1100 }, { t('Weil divisor') }, { condition = tex.in_text }),
	s({ trig = 'nc', name = '-1-curve', priority = 1100 }, { t('\\((-1)\\)-curve') }, { condition = tex.in_text }),
	s(
		{ trig = 'iff', name = 'if and only if', priority = 1100 },
		{ t('if and only if ') },
		{ condition = tex.in_text }
	),
	s(
		{ trig = 'wrt', name = 'with respect to', priority = 1100 },
		{ t('with respect to ') },
		{ condition = tex.in_text }
	),
	s({ trig = 'nbhd', name = 'neighbourhood', priority = 1100 }, { t('neighbourhood') }, { condition = tex.in_text }),
	s(
		{ trig = 'pef', name = 'pseudo-effective', priority = 1100 },
		{ t('pseudo-effective') },
		{ condition = tex.in_text }
	),
	s(
		{ trig = 'gbgs', name = 'generated by global sections', priority = 1100 },
		{ t('generated by global sections') },
		{ condition = tex.in_text }
	),
	s(
		{ trig = 'fgd', name = 'finitely generated', priority = 1100 },
		{ t('finitely generated') },
		{ condition = tex.in_text }
	),
	s(
		{ trig = 'mfs', name = 'Mori fibre space', priority = 1100 },
		{ t('Mori fibre space') },
		{ condition = tex.in_text }
	),
	s(
		{ trig = 'bpf', name = 'base point free', priority = 1100 },
		{ t('base point free') },
		{ condition = tex.in_text }
	),
	s({ trig = 'snc', name = 'simple normal crossing', priority = 1100 }, { t('simple normal crossing') }, {
		condition = tex.in_text,
	}),
	s(
		{ trig = 'lmm', name = 'log minimal model', priority = 1100 },
		{ t('log minimal model') },
		{ condition = tex.in_text }
	),
	s(
		{ trig = '([tT])fae', name = 'the following are equivalent', regTrig = true, priority = 1100 },
		{ f(function(_, snip)
			return snip.captures[1] .. 'he following are equivalent'
		end, {}) },
		{ condition = pipe { conds.line_begin, tex.in_text } }
	),
	s(
		{ trig = '([wW])log', name = 'without loss of generality', regTrig = true, priority = 1100 },
		{ f(function(_, snip)
			return snip.captures[1] .. 'ithout loss of generality'
		end, {}) },
		{ condition = pipe { conds.line_begin, tex.in_text } }
	),
}

return snips, autosnips
